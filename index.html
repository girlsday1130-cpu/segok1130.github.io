<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>금성의 위상 변화 시뮬레이션 (최종 완성판)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* 모바일 스크롤 방지 */
        }
        .canvas-container {
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .active-btn {
            background-color: #4f46e5;
            color: white;
        }
        .inactive-btn {
            background-color: #e0e7ff;
            color: #4338ca;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-900">금성의 위상 및 시지름 변화 시뮬레이션</h1>
            <p class="mt-2 text-slate-600">금성을 드래그하여 위치를 바꾸고, 지구에서 본 금성의 모습을 확인해보세요.</p>
        </header>

        <div class="mb-4 flex justify-center space-x-2">
            <button id="ptolemy-btn" class="px-4 py-2 rounded-lg font-semibold transition-colors duration-200">프톨레마이오스 (천동설)</button>
            <button id="copernicus-btn" class="px-4 py-2 rounded-lg font-semibold transition-colors duration-200">코페르니쿠스 (지동설)</button>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-2 bg-white p-4 rounded-xl canvas-container">
                 <h2 id="model-title" class="text-xl font-semibold text-center mb-2"></h2>
                <canvas id="orbital-canvas" class="w-full aspect-square cursor-pointer"></canvas>
            </div>
            <div class="bg-white p-4 rounded-xl canvas-container flex flex-col justify-center items-center">
                <h2 class="text-xl font-semibold text-center mb-2">지구에서 본 금성</h2>
                <div class="w-48 h-48 md:w-64 md:h-64 bg-black rounded-full flex items-center justify-center overflow-hidden">
                    <canvas id="phase-canvas"></canvas>
                </div>
                 <div id="info-text" class="mt-4 text-center text-sm text-slate-500">
                    <p>천동설에서는 금성이 보름달 모양으로 보일 수 없습니다.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const orbitalCanvas = document.getElementById('orbital-canvas');
        const phaseCanvas = document.getElementById('phase-canvas');
        const ptolemyBtn = document.getElementById('ptolemy-btn');
        const copernicusBtn = document.getElementById('copernicus-btn');
        const modelTitle = document.getElementById('model-title');
        const infoText = document.getElementById('info-text');

        const orbitalCtx = orbitalCanvas.getContext('2d');
        const phaseCtx = phaseCanvas.getContext('2d');

        let currentModel = 'copernicus';
        let venusAngle = Math.PI / 4;
        let isDragging = false;
        
        function resizeCanvases() {
            const orbitalSize = orbitalCanvas.clientWidth;
            orbitalCanvas.width = orbitalSize;
            orbitalCanvas.height = orbitalSize;
            
            const phaseContainer = phaseCanvas.parentElement;
            const phaseSize = Math.min(phaseContainer.clientWidth, phaseContainer.clientHeight);
            phaseCanvas.width = phaseSize;
            phaseCanvas.height = phaseSize;
        }

        const bodies = {
            sun: { color: '#FFD700', radius: 18 },
            earth: { color: '#4A90E2', radius: 12 },
            venus: { color: '#F8F0C8', radius: 10 }
        };

        function drawBody(ctx, body, pos) {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, body.radius, 0, 2 * Math.PI);
            ctx.fillStyle = body.color;
            ctx.fill();
        }
        
        function drawLabel(ctx, text, pos) {
            ctx.fillStyle = '#334155';
            ctx.font = '14px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(text, pos.x, pos.y + 28);
        }

        function drawOrbit(ctx, center, radius) {
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function animate() {
            orbitalCtx.clearRect(0, 0, orbitalCanvas.width, orbitalCanvas.height);
            phaseCtx.clearRect(0, 0, phaseCanvas.width, phaseCanvas.height);

            const W = orbitalCanvas.width;
            const center = { x: W / 2, y: W / 2 };

            let sunPos, earthPos, venusPos;
            
            if (currentModel === 'ptolemy') {
                const sunOrbitRadius = W * 0.4;
                const venusEpicycleRadius = W * 0.2;
                earthPos = center;
                sunPos = { x: center.x + sunOrbitRadius * Math.cos(venusAngle), y: center.y + sunOrbitRadius * Math.sin(venusAngle) };
                const epicycleCenter = { x: center.x + (sunOrbitRadius * 0.7) * Math.cos(venusAngle), y: center.y + (sunOrbitRadius * 0.7) * Math.sin(venusAngle) };
                venusPos = { x: epicycleCenter.x + venusEpicycleRadius * Math.cos(venusAngle * 2.5), y: epicycleCenter.y + venusEpicycleRadius * Math.sin(venusAngle * 2.5) };
                drawOrbit(orbitalCtx, center, sunOrbitRadius);
                drawOrbit(orbitalCtx, epicycleCenter, venusEpicycleRadius);
            } else {
                const earthOrbitRadius = W * 0.4;
                const venusOrbitRadius = W * 0.25;
                sunPos = center;
                earthPos = { x: center.x + earthOrbitRadius * Math.cos(Math.PI), y: center.y + earthOrbitRadius * Math.sin(Math.PI) };
                venusPos = { x: center.x + venusOrbitRadius * Math.cos(venusAngle), y: center.y + venusOrbitRadius * Math.sin(venusAngle) };
                drawOrbit(orbitalCtx, center, venusOrbitRadius);
                drawOrbit(orbitalCtx, center, earthOrbitRadius);
            }
            
            drawBody(orbitalCtx, bodies.sun, sunPos);
            drawLabel(orbitalCtx, '태양', sunPos);
            drawBody(orbitalCtx, bodies.earth, earthPos);
            drawLabel(orbitalCtx, '지구', earthPos);
            drawBody(orbitalCtx, bodies.venus, venusPos);
            drawLabel(orbitalCtx, '금성', venusPos);

            drawVenusPhase(sunPos, earthPos, venusPos);

            requestAnimationFrame(animate);
        }

        function drawVenusPhase(sunPos, earthPos, venusPos) {
            const distEV = Math.hypot(earthPos.x - venusPos.x, earthPos.y - venusPos.y);
            const apparentRadius = Math.min((orbitalCanvas.width * 15) / distEV, phaseCanvas.width / 2.05);

            const VtoE = { x: earthPos.x - venusPos.x, y: earthPos.y - venusPos.y };
            const VtoS = { x: sunPos.x - venusPos.x, y: sunPos.y - venusPos.y };

            const dotProduct = VtoE.x * VtoS.x + VtoE.y * VtoS.y;
            const magVtoE = Math.hypot(VtoE.x, VtoE.y);
            const magVtoS = Math.hypot(VtoS.x, VtoS.y);
            let cosPhase = dotProduct / (magVtoE * magVtoS);
            
            if (currentModel === 'ptolemy') {
                if (cosPhase > 0) {
                    cosPhase = 0;
                }
            }
            
            const pCenter = { x: phaseCanvas.width / 2, y: phaseCanvas.height / 2 };

            phaseCtx.save();
            phaseCtx.translate(pCenter.x, pCenter.y);

            let orientationAngle = Math.atan2(sunPos.y - earthPos.y, sunPos.x - earthPos.x) - Math.atan2(venusPos.y - earthPos.y, venusPos.x - earthPos.x);

            if (orientationAngle > Math.PI) orientationAngle -= 2 * Math.PI;
            if (orientationAngle < -Math.PI) orientationAngle += 2 * Math.PI;

            phaseCtx.rotate(orientationAngle);

            phaseCtx.fillStyle = bodies.venus.color;
            phaseCtx.beginPath();
            
            phaseCtx.arc(0, 0, apparentRadius, -Math.PI / 2, Math.PI / 2, false);
            
            phaseCtx.ellipse(0, 0, apparentRadius * Math.abs(cosPhase), apparentRadius, 0, Math.PI / 2, -Math.PI / 2, cosPhase < 0);
            
            phaseCtx.fill();
            phaseCtx.restore();
        }

        function setModel(model) {
            currentModel = model;
            if (model === 'ptolemy') {
                ptolemyBtn.classList.add('active-btn'); ptolemyBtn.classList.remove('inactive-btn');
                copernicusBtn.classList.add('inactive-btn'); copernicusBtn.classList.remove('active-btn');
                modelTitle.textContent = "프톨레마이오스 모델 (천동설)";
                infoText.style.display = 'block';
            } else {
                copernicusBtn.classList.add('active-btn'); copernicusBtn.classList.remove('inactive-btn');
                ptolemyBtn.classList.add('inactive-btn'); ptolemyBtn.classList.remove('active-btn');
                modelTitle.textContent = "코페르니쿠스 모델 (지동설)";
                infoText.style.display = 'none';
            }
        }

        ptolemyBtn.addEventListener('click', () => setModel('ptolemy'));
        copernicusBtn.addEventListener('click', () => setModel('copernicus'));

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.clientX || (evt.touches && evt.touches[0].clientX);
            const clientY = evt.clientY || (evt.touches && evt.touches[0].clientY);
            return {
                x: (clientX - rect.left) * (canvas.width / rect.width),
                y: (clientY - rect.top) * (canvas.height / rect.height)
            };
        }
        
        function handleDragStart(e) { e.preventDefault(); isDragging = true; }
        function handleDragMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            const pos = getMousePos(orbitalCanvas, e);
            const center = { x: orbitalCanvas.width / 2, y: orbitalCanvas.height / 2 };
            const newAngle = Math.atan2(pos.y - center.y, pos.x - center.x);

            if (currentModel === 'copernicus') {
                venusAngle = newAngle;
            } else {
                let delta = newAngle - venusAngle;

                if (delta > Math.PI) delta -= 2 * Math.PI;
                if (delta < -Math.PI) delta += 2 * Math.PI;

                venusAngle += delta;
            }
        }
        function handleDragEnd(e) { e.preventDefault(); isDragging = false; }

        orbitalCanvas.addEventListener('mousedown', handleDragStart);
        orbitalCanvas.addEventListener('mousemove', handleDragMove);
        orbitalCanvas.addEventListener('mouseup', handleDragEnd);
        orbitalCanvas.addEventListener('mouseleave', handleDragEnd);
        orbitalCanvas.addEventListener('touchstart', handleDragStart);
        orbitalCanvas.addEventListener('touchmove', handleDragMove);
        orbitalCanvas.addEventListener('touchend', handleDragEnd);
        orbitalCanvas.addEventListener('touchcancel', handleDragEnd);

        window.addEventListener('resize', resizeCanvases);
        
        resizeCanvases();
        setModel('copernicus');
        animate();
    </script>
</body>
</html>

